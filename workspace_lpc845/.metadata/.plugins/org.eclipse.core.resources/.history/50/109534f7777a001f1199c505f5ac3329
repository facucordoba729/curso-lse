#include "board.h"
#include "fsl_swm.h"
#include "fsl_i2c.h"
#include "fsl_debug_console.h"
#include "fsl_pwm.h"   // Librería para controlar el PWM

// Direccion del BH1750
#define BH1750_ADDR	0x5c

// Definir rango máximo de lux que consideraremos (ejemplo: 1000 lux)
#define MAX_LUX 1000

/**
 * @brief Inicialización del PWM para controlar el LED
 */
void init_pwm(void) {
    pwm_config_t pwmConfig;
    PWM_GetDefaultConfig(&pwmConfig);
    pwmConfig.enableDebugMode = true;
    pwmConfig.prescale = kPWM_Prescale_Divide_16;  // Configuramos el prescaler del PWM
    PWM_Init(PWM0, kPWM_Module_0, &pwmConfig);    // Inicializamos el módulo PWM

    // Configuración de la señal PWM para el LED en un pin específico
    pwm_signal_param_t pwmSignal;
    pwmSignal.pwmChannel = kPWM_PwmA;             // Canal PWM
    pwmSignal.level = kPWM_HighTrue;              // Nivel activo
    pwmSignal.dutyCyclePercent = 0;               // Ciclo de trabajo inicial al 0%
    PWM_SetupPwm(PWM0, kPWM_Module_0, &pwmSignal, 1, 24000U, 24000000U, false);  // Frecuencia 24kHz
    PWM_StartTimer(PWM0, kPWM_Control_Module_0);
}

/**
 * @brief Ajusta el brillo del LED en función de la intensidad de luz
 * @param lux Valor de intensidad lumínica medida por el sensor
 */
void ajustar_brillo_led(float lux) {
    uint8_t brillo;

    // Limitar el valor de lux al máximo definido
    if (lux > MAX_LUX) {
        lux = MAX_LUX;
    }

    // Proporcionalidad lineal: brillo entre 0% y 100% según el lux medido
    brillo = (uint8_t)((lux / MAX_LUX) * 100);

    // Ajustar el ciclo de trabajo del PWM (duty cycle)
    PWM_UpdatePwmDutycycle(PWM0, kPWM_Module_0, kPWM_PwmA, brillo);
}

/**
 * @brief Programa principal
 */
int main(void) {
	// Arranco de 30 MHz
	BOARD_BootClockFRO30M();

	// Inicializo el clock del I2C1
	CLOCK_Select(kI2C1_Clk_From_MainClk);
    // Asigno las funciones de I2C1 a los pines 26 y 27
	CLOCK_EnableClock(kCLOCK_Swm);
    SWM_SetMovablePinSelect(SWM0, kSWM_I2C1_SDA, kSWM_PortPin_P0_27);
    SWM_SetMovablePinSelect(SWM0, kSWM_I2C1_SCL, kSWM_PortPin_P0_26);
    CLOCK_DisableClock(kCLOCK_Swm);

    // Configuración de master para el I2C con 1 KHz de clock
    i2c_master_config_t config;
    I2C_MasterGetDefaultConfig(&config);
    config.baudRate_Bps = 1000;
    // Usa el clock del sistema de base para generar el de la comunicación
    I2C_MasterInit(I2C1, &config, SystemCoreClock);

    // Inicializo el PWM para controlar el LED
    init_pwm();

	if(I2C_MasterStart(I2C1, BH1750_ADDR, kI2C_Write) == kStatus_Success) {
		// Comando de power on
		uint8_t cmd = 0x01;
		I2C_MasterWriteBlocking(I2C1, &cmd, 1, kI2C_TransferDefaultFlag);
		I2C_MasterStop(I2C1);
	}
	if(I2C_MasterStart(I2C1, BH1750_ADDR, kI2C_Write) == kStatus_Success) {
		// Comando de medición continua a 1 lux de resolución
		uint8_t cmd = 0x10;
		I2C_MasterWriteBlocking(I2C1, &cmd, 1, kI2C_TransferDefaultFlag);
		I2C_MasterStop(I2C1);
	}

	while(1) {
		// Lectura del sensor
		if(I2C_MasterStart(I2C1, BH1750_ADDR, kI2C_Read) == kStatus_Success) {
			// Resultado
			uint8_t res[2] = {0};
			I2C_MasterReadBlocking(I2C1, res, 2, kI2C_TransferDefaultFlag);
			I2C_MasterStop(I2C1);
			// Devuelvo el resultado
			float lux = ((res[0] << 8) + res[1]) / 1.2;
			PRINTF("LUX : %d \r\n",(uint16_t) lux);

			// Ajustar el brillo del LED en función de la intensidad lumínica
			ajustar_brillo_led(lux);
		}
    }
    return 0;
}
